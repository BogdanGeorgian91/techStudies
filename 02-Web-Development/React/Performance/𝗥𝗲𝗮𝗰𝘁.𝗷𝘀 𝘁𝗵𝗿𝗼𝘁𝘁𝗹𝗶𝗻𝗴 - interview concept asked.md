
This one concept showed up in almost every interview â€” and instantly revealed who truly gets JavaScript.

ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ—§ğ—µğ—¿ğ—¼ğ˜ğ˜ğ—¹ğ—¶ğ—»ğ—´?
Throttling limits how often a function runs, no matter how frequently the event fires. Itâ€™s a performance lifesaver when dealing with high-frequency events like scroll, mousemove, or resize.

ğ—¥ğ—²ğ—®ğ—¹-ğ—Ÿğ—¶ğ—³ğ—² ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²: ğ— ğ—¼ğ˜‚ğ˜€ğ—² ğ— ğ—¼ğ˜ƒğ—² ğ—˜ğ˜ƒğ—²ğ—»ğ˜
ğ—¦ğ—®ğ˜† ğ˜†ğ—¼ğ˜‚â€™ğ—¿ğ—² ğ˜ğ—¿ğ—®ğ—°ğ—¸ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—ºğ—¼ğ˜‚ğ˜€ğ—² ğ—ºğ—¼ğ˜ƒğ—²ğ—ºğ—²ğ—»ğ˜ ğ—®ğ—»ğ—± ğ˜€ğ—²ğ—»ğ—±ğ—¶ğ—»ğ—´ ğ—¶ğ˜ ğ˜ğ—¼ ğ˜ğ—µğ—² ğ˜€ğ—²ğ—¿ğ˜ƒğ—²ğ—¿:
const handleMouseMove = (e) => {
Â console.log('API call to do some operations...');
};
window.addEventListener('mousemove', handleMouseMove);
ğ—§ğ—µğ—¶ğ˜€ ğ—°ğ—¼ğ˜‚ğ—¹ğ—± ğ—°ğ—®ğ˜‚ğ˜€ğ—² ğŸ­ğŸ²ğŸ¬ğŸ¬+ ğ—”ğ—£ğ—œ ğ—°ğ—®ğ—¹ğ—¹ğ˜€ ğ—¶ğ—» ğ—·ğ˜‚ğ˜€ğ˜ ğ—® ğ—³ğ—²ğ˜„ ğ˜€ğ—²ğ—°ğ—¼ğ—»ğ—±ğ˜€.

ğ—Ÿğ—²ğ˜â€™ğ˜€ ğ—™ğ—¶ğ˜… ğ—¶ğ˜ ğ˜„ğ—¶ğ˜ğ—µ ğ—§ğ—µğ—¿ğ—¼ğ˜ğ˜ğ—¹ğ—¶ğ—»ğ—´:
function throttle(fn, delay) {
Â let run = false;
Â return function (...args) {
Â Â if (!run) {
Â Â Â fn(...args);
Â Â Â run = true;
Â Â Â setTimeout(() => (run = false), delay);
Â Â }
Â };
}
const handleMouseMove = (e) => {
Â console.log('API call to do some operations...');
};
window.addEventListener('mousemove', throttle(handleMouseMove, 1000));
ğ—¡ğ—¼ğ˜„ ğ—¼ğ—»ğ—¹ğ˜† ğ—¼ğ—»ğ—² ğ—”ğ—£ğ—œ ğ—°ğ—®ğ—¹ğ—¹ ğ—½ğ—²ğ—¿ ğ˜€ğ—²ğ—°ğ—¼ğ—»ğ—±!

ğ—–ğ—¼ğ—»ğ—°ğ—¹ğ˜‚ğ˜€ğ—¶ğ—¼ğ—»
1ï¸âƒ£ Debounce vs. Throttleâ€”both are powerful.
2ï¸âƒ£ Use throttle to limit frequency.
3ï¸âƒ£ Use debounce to wait until an event stops firing.

ğ—ªğ—®ğ—»ğ˜ ğ—µğ—®ğ—»ğ—±ğ˜€-ğ—¼ğ—» ğ—²ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²ğ˜€ ğ—®ğ—»ğ—± ğ—±ğ—²ğ˜ğ—®ğ—¶ğ—¹ğ—²ğ—± ğ—°ğ—¼ğ—±ğ—²? ğ—–ğ—µğ—²ğ—°ğ—¸ ğ—¼ğ˜‚ğ˜ ğ˜ğ—µğ—² ğ—³ğ˜‚ğ—¹ğ—¹ ğ—šğ—¶ğ˜ğ—›ğ˜‚ğ—¯ ğ—¿ğ—²ğ—½ğ—¼ ğ—µğ—²ğ—¿ğ—²!
ğŸ‘‰ GitHub Repo:  https://lnkd.in/gWYZp7NT